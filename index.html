<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDGEHOG ISLAND LABOLATORY - FPS with Jump & Gravity & Interaction</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #controls-help {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            font-family: sans-serif;
            border-radius: 8px;
            z-index: 100;
            font-size: 14px;
            line-height: 1.6;
            max-width: 250px;
        }

        #controls-help h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 16px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        #controls-help p {
            margin: 4px 0;
        }

        #controls-help kbd {
            background-color: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 13px;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 200;
        }

        #instructions {
            width: 50%;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="blocker">
        <div id="instructions">
            <p style="font-size:36px">Click to play</p>
            <p>
                W, A, S, D: Move<br />
                Shift: Sprint<br />
                Space: Jump<br />
                E: Interact<br />
                Mouse: Look around
            </p>
        </div>
    </div>

    <div id="controls-help">
        <h3>Petunjuk Kontrol</h3>
        <p><kbd>W</kbd> - Maju</p>
        <p><kbd>A</kbd> - Kiri (Strafe)</p>
        <p><kbd>S</kbd> - Mundur</p>
        <p><kbd>D</kbd> - Kanan (Strafe)</p>
        <p><kbd>Shift Kiri</kbd> - Sprint</p>
        <p><kbd>Space</kbd> - Lompat</p>
        <p><kbd>E</kbd> - Interaksi</p>
        <p><strong>Mouse</strong> - Lihat Sekeliling (Klik layar untuk mengaktifkan)</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let scene, camera, renderer, model, controls;
        const clock = new THREE.Clock();

        const keys = {
            W: false, A: false, S: false, D: false,
            SHIFT_LEFT: false,
            SPACE: false,
            E: false
        };

        const PLAYER_EYE_HEIGHT = 10.5;
        const PLAYER_COLLISION_HEIGHT = 1.8;
        const GRAVITY = 5.0;
        const JUMP_IMPULSE = 3.5;
        const MAX_STEP_HEIGHT = 0.6;
        const playerRadiusBuffer = 4.0;
        const PLAYER_FEET_RADIUS = playerRadiusBuffer * 0.8;
        const INTERACTION_DISTANCE = 15.0;

        let player = {
            position: new THREE.Vector3(),
            velocity: new THREE.Vector3(),
            isGrounded: false,
            canJump: true,
            boundingBox: new THREE.Box3()
        };

        const raycaster = new THREE.Raycaster();
        const interactionRaycaster = new THREE.Raycaster();
        const collidableMeshes = [];
        const collidableObjectNames = [
            'Object_13108', 'Object_13105',
            'Object_22', 'Object_23', 'Object_14',
            'Object_15', 'Object_16', 'Object_18',
            'Object_6', 'Object_20', 'Object_25', 'Object_24'
        ];
        const interactiveObjectNames = ['Object_13108', 'Object_23', 'Object_18'];
        const collisionBoundingBoxes = new Map();

        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');

        const _worldDirection = new THREE.Vector3();
        const _movementDirection = new THREE.Vector3();
        const _forward = new THREE.Vector3();
        const _right = new THREE.Vector3();

        let tvScreenMesh, paperObject, steamObject, steamTriggerObject;
        let isTVOn = false;
        let originalTVMaterial, staticTVMaterial; // Tambahkan staticTVMaterial
        let staticTexture; // Untuk menyimpan tekstur static

        let isPaperAnimating = false;
        let paperAnimationTime = 0;
        const PAPER_ANIMATION_DURATION = 0.5;
        let originalPaperRotation;

        let isSteamActive = false;
        let steamAnimationTime = 0;
        const STEAM_LOOP_DURATION = 2.0;
        const STEAM_MAX_HEIGHT_OFFSET = 10.0;
        let originalSteamPosition;
        let originalSteamOpacity;


        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);
            controls = new PointerLockControls(camera, document.body);
            instructions.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
                document.getElementById('controls-help').style.display = 'block';
            });
            controls.addEventListener('unlock', () => {
                blocker.style.display = 'flex';
                instructions.style.display = '';
                document.getElementById('controls-help').style.display = 'none';
            });
            document.getElementById('controls-help').style.display = 'none';
            setupLighting();

            // Load Tekstur Static Screen
            const textureLoader = new THREE.TextureLoader();
            staticTexture = textureLoader.load('television.jpeg', // GANTI DENGAN NAMA FILE TEKSTUR ANDA
                (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    console.log("Static screen texture loaded successfully.");
                    // Buat material static setelah tekstur dimuat
                    staticTVMaterial = new THREE.MeshStandardMaterial({
                        map: staticTexture,
                        emissiveMap: staticTexture, // Bisa juga pakai emissive agar terlihat menyala
                        emissive: 0xffffff,       // Warna emissive (putih agar tekstur terlihat jelas)
                        emissiveIntensity: 0.5    // Intensitas nyala
                    });
                },
                undefined,
                (error) => {
                    console.error("Error loading static screen texture:", error);
                    // Fallback jika tekstur gagal dimuat
                    staticTVMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, emissive: 0x333333, emissiveIntensity: 1 });
                }
            );


            const loader = new GLTFLoader();
            loader.load('EDGEHOG ISLAND LABOLATORY.glb', (gltf) => {
                model = gltf.scene;
                model.traverse((child) => {
                    // console.log(`Object Name: ${child.name}, Type: ${child.type}, UUID: ${child.uuid}`);
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (collidableObjectNames.includes(child.name)) {
                            collidableMeshes.push(child);
                            collisionBoundingBoxes.set(child.name, new THREE.Box3().setFromObject(child));
                        }
                    }
                });

                tvScreenMesh = model.getObjectByName('Object_13105');
                if (tvScreenMesh && tvScreenMesh.isMesh && tvScreenMesh.material) {
                    originalTVMaterial = tvScreenMesh.material.clone();
                    console.log("TV Screen Mesh (Object_13105) found and material stored.");
                } else {
                    console.error("CRITICAL: TV Screen Mesh (Object_13105) not found or has no material. TV interaction will not work correctly.");
                }

                paperObject = model.getObjectByName('Object_23');
                if (paperObject && paperObject.isMesh) {
                    originalPaperRotation = paperObject.rotation.clone();
                }
                steamObject = model.getObjectByName('Object_17');
                if (steamObject && steamObject.isMesh) {
                    originalSteamPosition = steamObject.position.clone();
                    if (steamObject.material) {
                        steamObject.material.transparent = true;
                        originalSteamOpacity = steamObject.material.opacity;
                        steamObject.visible = false;
                    }
                }
                steamTriggerObject = model.getObjectByName('Object_18');

                model.scale.set(0.05, 0.05, 0.05);
                scene.add(model);

                const targetObjectName = 'Object_6';
                let targetObject = model.getObjectByName(targetObjectName);
                if (targetObject) {
                    const boundingBox = new THREE.Box3().setFromObject(targetObject);
                    targetObject.getWorldPosition(player.position);
                    player.position.y = boundingBox.max.y;
                    player.isGrounded = true;
                } else {
                    player.position.set(0, 10, 5);
                }
                controls.getObject().position.set(player.position.x, player.position.y + PLAYER_EYE_HEIGHT, player.position.z);
                player.boundingBox.setFromCenterAndSize(
                    new THREE.Vector3(player.position.x, player.position.y + PLAYER_COLLISION_HEIGHT / 2, player.position.z),
                    new THREE.Vector3(playerRadiusBuffer * 2, PLAYER_COLLISION_HEIGHT, playerRadiusBuffer * 2)
                );
                animate();
            }, (xhr) => console.log((xhr.loaded / xhr.total * 100) + '% loaded'), (error) => console.error(error));

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize, false);
        }

        function setupLighting() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dirLight = new THREE.DirectionalLight(0xffffff, 3.5);
            dirLight.position.set(40, 50, 30);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 150;
            dirLight.shadow.bias = -0.0005;
            scene.add(dirLight);
        }

        function onKeyDown(event) {
            const key = event.code.replace('Key', '').replace('Left', '_LEFT');
            if (keys.hasOwnProperty(key)) keys[key] = true;

            if (event.code === 'KeyE' && controls.isLocked) {
                handleInteraction();
            }
        }

        function onKeyUp(event) {
            const key = event.code.replace('Key', '').replace('Left', '_LEFT');
            if (keys.hasOwnProperty(key)) keys[key] = false;
        }

        function handleInteraction() {
            interactionRaycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const interactableSceneObjects = [];
            interactiveObjectNames.forEach(name => {
                const obj = model.getObjectByName(name);
                if (obj) interactableSceneObjects.push(obj);
            });
            const intersects = interactionRaycaster.intersectObjects(interactableSceneObjects, true);

            if (intersects.length > 0 && intersects[0].distance < INTERACTION_DISTANCE) {
                const intersectedObject = intersects[0].object;
                let interactiveObjectName = intersectedObject.name;
                let current = intersectedObject;
                while (current && !interactiveObjectNames.includes(current.name)) {
                    current = current.parent;
                }
                if (current) {
                    interactiveObjectName = current.name;
                }

                console.log("Interacting with:", interactiveObjectName);
                if (interactiveObjectName === 'Object_13108' && tvScreenMesh && originalTVMaterial && staticTVMaterial) { // Pastikan staticTVMaterial sudah ada
                    isTVOn = !isTVOn;
                    if (isTVOn) {
                        tvScreenMesh.material = staticTVMaterial;
                        console.log("TV ON - Static Screen");
                    } else {
                        tvScreenMesh.material = originalTVMaterial;
                        console.log("TV OFF");
                    }
                } else if (interactiveObjectName === 'Object_23' && paperObject && !isPaperAnimating) {
                    isPaperAnimating = true;
                    paperAnimationTime = 0;
                } else if (interactiveObjectName === 'Object_18' && steamObject) {
                    isSteamActive = !isSteamActive;
                    if (isSteamActive) {
                        steamAnimationTime = 0;
                        steamObject.position.copy(originalSteamPosition);
                        if (steamObject.material) steamObject.material.opacity = originalSteamOpacity;
                        steamObject.visible = true;
                        console.log("Steam Activated");
                    } else {
                        steamObject.visible = false;
                        console.log("Steam Deactivated");
                    }
                }
            }
        }

        function updatePlayerAndCamera(deltaTime) {
            if (!controls.isLocked) {
                player.velocity.x = 0;
                player.velocity.z = 0;
                return;
            }
            // --- Player Movement Logic (Unchanged) ---
            const camRef = controls.getObject();
            const speed = (keys.SHIFT_LEFT ? 1.5 : 1) * 8.0 * deltaTime;
            camRef.getWorldDirection(_forward);
            _forward.y = 0; _forward.normalize();
            _right.crossVectors(camRef.up, _forward).normalize();
            _movementDirection.set(0, 0, 0);
            if (keys.W) _movementDirection.add(_forward);
            if (keys.S) _movementDirection.sub(_forward);
            if (keys.A) _movementDirection.add(_right);
            if (keys.D) _movementDirection.sub(_right);

            if (!player.isGrounded) player.velocity.y -= GRAVITY * deltaTime;
            if (keys.SPACE && player.isGrounded && player.canJump) {
                player.velocity.y = JUMP_IMPULSE;
                player.isGrounded = false;
                player.canJump = false;
            }
            if (!keys.SPACE) player.canJump = true;

            let dX = 0, dZ = 0;
            if (_movementDirection.lengthSq() > 0) {
                _movementDirection.normalize();
                dX = _movementDirection.x * speed;
                dZ = _movementDirection.z * speed;
            }

            const groundRayOrigin = new THREE.Vector3(player.position.x, player.position.y + PLAYER_FEET_RADIUS * 0.5, player.position.z);
            raycaster.set(groundRayOrigin, new THREE.Vector3(0, -1, 0));
            raycaster.far = Math.abs(player.velocity.y * deltaTime) + PLAYER_FEET_RADIUS * 1.1;
            const groundHits = raycaster.intersectObjects(collidableMeshes, true);
            player.isGrounded = false;
            if (player.velocity.y <= 0 && groundHits.length > 0 && groundHits[0].distance <= PLAYER_FEET_RADIUS * 1.01) {
                player.position.y = groundHits[0].point.y;
                player.velocity.y = 0;
                player.isGrounded = true;
            }
            if (!player.isGrounded) player.position.y += player.velocity.y * deltaTime;

            if (player.velocity.y > 0) {
                const headOrigin = player.position.clone().add(new THREE.Vector3(0, PLAYER_COLLISION_HEIGHT - 0.1, 0));
                raycaster.set(headOrigin, new THREE.Vector3(0, 1, 0));
                raycaster.far = player.velocity.y * deltaTime + 0.2;
                const headHits = raycaster.intersectObjects(collidableMeshes, true);
                if (headHits.length > 0) {
                    player.position.y = headHits[0].point.y - PLAYER_COLLISION_HEIGHT;
                    player.velocity.y = 0;
                }
            }

            const tempPos = player.position.clone();
            tempPos.x += dX; tempPos.z += dZ;
            player.boundingBox.setFromCenterAndSize(
                new THREE.Vector3(tempPos.x, player.position.y + PLAYER_COLLISION_HEIGHT / 2, tempPos.z),
                new THREE.Vector3(playerRadiusBuffer * 2, PLAYER_COLLISION_HEIGHT, playerRadiusBuffer * 2)
            );
            let canMoveH = true; let stepped = false;
            if (dX !== 0 || dZ !== 0) {
                for (const mesh of collidableMeshes) {
                    const box = collisionBoundingBoxes.get(mesh.name);
                    if (box && !box.isEmpty() && player.boundingBox.intersectsBox(box)) {
                        let didStep = false;
                        const headClearOrigin = player.position.clone();
                        headClearOrigin.x += _movementDirection.x * playerRadiusBuffer * 0.5;
                        headClearOrigin.z += _movementDirection.z * playerRadiusBuffer * 0.5;
                        headClearOrigin.y += MAX_STEP_HEIGHT + 0.1;
                        raycaster.set(headClearOrigin, _movementDirection);
                        raycaster.far = playerRadiusBuffer;
                        if (raycaster.intersectObject(mesh, true).length === 0) {
                            const stepSurfOrigin = new THREE.Vector3(tempPos.x, player.position.y + MAX_STEP_HEIGHT + PLAYER_FEET_RADIUS, tempPos.z);
                            raycaster.set(stepSurfOrigin, new THREE.Vector3(0, -1, 0));
                            raycaster.far = MAX_STEP_HEIGHT + PLAYER_FEET_RADIUS * 1.5;
                            const stepHits = raycaster.intersectObject(mesh, true);
                            if (stepHits.length > 0) {
                                const yDiff = stepHits[0].point.y - player.position.y;
                                if (yDiff >= -0.01 && yDiff <= MAX_STEP_HEIGHT) {
                                    player.position.set(tempPos.x, stepHits[0].point.y, tempPos.z);
                                    player.isGrounded = true; player.velocity.y = 0;
                                    stepped = true; didStep = true; break;
                                }
                            }
                        }
                        if (!didStep) { canMoveH = false; break; }
                    }
                }
            }
            if (!stepped && canMoveH) player.position.set(tempPos.x, player.position.y, tempPos.z);
            camRef.position.set(player.position.x, player.position.y + PLAYER_EYE_HEIGHT, player.position.z);
            // --- End Player Movement Logic ---


            // Animasi Interaktif
            if (isTVOn && staticTexture && staticTVMaterial === tvScreenMesh.material) { // Animasikan offset hanya jika TV menyala DENGAN material static
                staticTexture.offset.x += Math.random() * 0.1 - 0.05; // Gerakan acak kecil
                staticTexture.offset.y += Math.random() * 0.1 - 0.05;
                // Pastikan offset tetap dalam rentang 0-1 agar repeat wrapping bekerja
                staticTexture.offset.x = (staticTexture.offset.x % 1 + 1) % 1;
                staticTexture.offset.y = (staticTexture.offset.y % 1 + 1) % 1;
            }


            if (isPaperAnimating && paperObject) {
                paperAnimationTime += deltaTime;
                const progress = paperAnimationTime / PAPER_ANIMATION_DURATION;
                paperObject.rotation.z = originalPaperRotation.z + Math.sin(progress * Math.PI * 4) * 0.15;
                if (paperAnimationTime >= PAPER_ANIMATION_DURATION) {
                    isPaperAnimating = false;
                    paperObject.rotation.copy(originalPaperRotation);
                }
            }

            if (isSteamActive && steamObject && originalSteamPosition && steamObject.material) {
                steamAnimationTime += deltaTime;
                let loopProgress = (steamAnimationTime % STEAM_LOOP_DURATION) / STEAM_LOOP_DURATION;
                steamObject.position.set(
                    originalSteamPosition.x,
                    originalSteamPosition.y + loopProgress * STEAM_MAX_HEIGHT_OFFSET,
                    originalSteamPosition.z
                );
                steamObject.material.opacity = originalSteamOpacity * (1 - loopProgress);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(0.05, clock.getDelta());
            updatePlayerAndCamera(deltaTime);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>