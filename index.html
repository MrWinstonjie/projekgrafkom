<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDGEHOG ISLAND LABOLATORY - FPS with Jump & Gravity & Interaction</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #controls-help {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            font-family: sans-serif;
            border-radius: 8px;
            z-index: 100;
            font-size: 14px;
            line-height: 1.6;
            max-width: 250px;
        }

        #controls-help h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 16px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        #controls-help p {
            margin: 4px 0;
        }

        #controls-help kbd {
            background-color: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 13px;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 200;
        }

        #instructions {
            width: 50%;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="blocker">
        <div id="instructions">
            <p style="font-size:36px">Click to play</p>
            <p>
                W, A, S, D: Move<br />
                Shift: Sprint<br />
                Space: Jump<br />
                E: Interact<br />
                Mouse: Look around
            </p>
        </div>
    </div>

    <div id="controls-help">
        <h3>Petunjuk Kontrol</h3>
        <p><kbd>W</kbd> - Maju</p>
        <p><kbd>A</kbd> - Kiri (Strafe)</p>
        <p><kbd>S</kbd> - Mundur</p>
        <p><kbd>D</kbd> - Kanan (Strafe)</p>
        <p><kbd>Shift Kiri</kbd> - Sprint</p>
        <p><kbd>Space</kbd> - Lompat</p>
        <p><kbd>E</kbd> - Interaksi</p>
        <p><strong>Mouse</strong> - Lihat Sekeliling (Klik layar untuk mengaktifkan)</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let scene, camera, renderer, model, controls;
        const clock = new THREE.Clock();

        const keys = {
            W: false, A: false, S: false, D: false,
            SHIFT_LEFT: false,
            SPACE: false,
            E: false
        };

        const PLAYER_EYE_HEIGHT = 10.5;
        const PLAYER_COLLISION_HEIGHT = 1.8;
        const GRAVITY = 5.0;
        const JUMP_IMPULSE = 3.5;
        const MAX_STEP_HEIGHT = 0.6;
        const playerRadiusBuffer = 4.0;
        const PLAYER_FEET_RADIUS = playerRadiusBuffer * 0.8;
        const INTERACTION_DISTANCE = 15.0;

        let player = {
            position: new THREE.Vector3(),
            velocity: new THREE.Vector3(),
            isGrounded: false,
            canJump: true,
            boundingBox: new THREE.Box3()
        };

        const raycaster = new THREE.Raycaster();
        const interactionRaycaster = new THREE.Raycaster();
        const collidableMeshes = [];
        const collidableObjectNames = [
            'Object_13108', 'Object_13105',
            'Object_22', 'Object_23', 'Object_14', // 'Object_23' is the interactive parent/group for the paper
            'Object_15', 'Object_16', 'Object_18',
            'Object_6', 'Object_20', 'Object_25', 'Object_24'
        ];
        const interactiveObjectNames = ['Object_13108', 'Object_23', 'Object_18', 'Object_23025'];
        const collisionBoundingBoxes = new Map();

        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');

        const _worldDirection = new THREE.Vector3();
        const _movementDirection = new THREE.Vector3();
        const _forward = new THREE.Vector3();
        const _right = new THREE.Vector3();

        let tvScreenMesh, steamObject;
        let isTVOn = false;
        let originalTVMaterial, staticTVMaterial;
        let staticTexture;

        let isSteamActive = false;
        let steamAnimationTime = 0;
        const STEAM_LOOP_DURATION = 2.0;
        const STEAM_MAX_HEIGHT_OFFSET = 10.0;
        let originalSteamPosition;
        let originalSteamOpacity;

        // Paper Animation Variables
        let paperMesh; // This will hold the 'Object_23045' mesh
        let paperPrintTexture;
        let originalPaperMaterial; // Store original material
        let paperPrintMaterial; // Material with kertasprint.jpeg
        let isPaperTextureVisible = false; // Toggle state
        let paperAnimationActive = false;
        let paperAnimationTime = 0;
        const PAPER_ANIMATION_DURATION = 1.0; // 1 second animation
        let paperTargetOpacity = 0;
        let paperCurrentOpacity = 0;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);
            controls = new PointerLockControls(camera, document.body);
            instructions.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
                document.getElementById('controls-help').style.display = 'block';
            });
            controls.addEventListener('unlock', () => {
                blocker.style.display = 'flex';
                instructions.style.display = '';
                document.getElementById('controls-help').style.display = 'none';
            });
            document.getElementById('controls-help').style.display = 'none';
            setupLighting();

            const textureLoader = new THREE.TextureLoader();
            staticTexture = textureLoader.load('television.jpeg',
                (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    staticTVMaterial = new THREE.MeshStandardMaterial({
                        map: staticTexture,
                        emissiveMap: staticTexture,
                        emissive: 0xffffff,
                        emissiveIntensity: 0.5
                    });
                },
                undefined,
                (error) => {
                    console.error("Error loading static screen texture:", error);
                    staticTVMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, emissive: 0x333333, emissiveIntensity: 1 });
                }
            );

            // Load paper print texture
            paperPrintTexture = textureLoader.load('kertasprint.jpeg', 
                (texture) => {
                    console.log("Texture 'kertasprint.jpeg' loaded successfully.");
                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping; 
                    
                    // Create material with the loaded texture (transparent for animation)
                    paperPrintMaterial = new THREE.MeshStandardMaterial({
                        map: paperPrintTexture,
                        roughness: 0.8,
                        metalness: 0.1,
                        transparent: true,
                        opacity: 0 // Start invisible
                    });

                    console.log("Paper print material created with 'kertasprint.jpeg'.");
                },
                undefined,
                (error) => {
                    console.error("ERROR loading 'kertasprint.jpeg':", error);
                    // Create fallback material
                    paperPrintMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff, 
                        roughness: 0.8,
                        metalness: 0.1,
                        transparent: true,
                        opacity: 0
                    });
                }
            );

            const loader = new GLTFLoader();
            loader.load('EDGEHOG ISLAND LABOLATORY.glb', (gltf) => {
                model = gltf.scene;
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (collidableObjectNames.includes(child.name)) {
                            collidableMeshes.push(child);
                            collisionBoundingBoxes.set(child.name, new THREE.Box3().setFromObject(child));
                        }

                        if (child.name === 'Object_23045') { 
                            paperMesh = child;
                            // Store the original material
                            originalPaperMaterial = paperMesh.material ? paperMesh.material.clone() : new THREE.MeshStandardMaterial({color: 0xffffff, roughness: 0.8});
                            
                            console.log("SUCCESS: Paper mesh 'Object_23045' found.");
                        }
                    }
                });

                if (!paperMesh) {
                    console.error("CRITICAL ERROR: Paper mesh 'Object_23045' NOT FOUND. Paper toggle will not work.");
                }

                tvScreenMesh = model.getObjectByName('Object_13105');
                if (tvScreenMesh && tvScreenMesh.isMesh && tvScreenMesh.material) {
                    originalTVMaterial = tvScreenMesh.material.clone();
                }

                steamObject = model.getObjectByName('Object_17');
                if (steamObject && steamObject.isMesh) {
                    originalSteamPosition = steamObject.position.clone();
                    if (steamObject.material) {
                        steamObject.material.transparent = true;
                        originalSteamOpacity = steamObject.material.opacity;
                        steamObject.visible = false;
                    }
                }

                model.scale.set(0.05, 0.05, 0.05);
                scene.add(model);

                const targetObjectName = 'Object_6';
                let targetObject = model.getObjectByName(targetObjectName);
                if (targetObject) {
                    const boundingBox = new THREE.Box3().setFromObject(targetObject);
                    targetObject.getWorldPosition(player.position);
                    player.position.y = boundingBox.max.y;
                    player.isGrounded = true;
                } else {
                    player.position.set(0, 10, 5);
                }
                controls.getObject().position.set(player.position.x, player.position.y + PLAYER_EYE_HEIGHT, player.position.z);
                player.boundingBox.setFromCenterAndSize(
                    new THREE.Vector3(player.position.x, player.position.y + PLAYER_COLLISION_HEIGHT / 2, player.position.z),
                    new THREE.Vector3(playerRadiusBuffer * 2, PLAYER_COLLISION_HEIGHT, playerRadiusBuffer * 2)
                );
                animate();
            }, (xhr) => console.log((xhr.loaded / xhr.total * 100) + '% loaded'), (error) => console.error("GLTF Loading Error:", error));

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize, false);
        }

        function setupLighting() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dirLight = new THREE.DirectionalLight(0xffffff, 3.5);
            dirLight.position.set(40, 50, 30);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 150;
            dirLight.shadow.bias = -0.0005;
            scene.add(dirLight);
        }

        function onKeyDown(event) {
            const key = event.code.replace('Key', '').replace('Left', '_LEFT');
            if (keys.hasOwnProperty(key)) keys[key] = true;

            if (event.code === 'KeyE' && controls.isLocked) {
                handleInteraction();
            }
        }

        function onKeyUp(event) {
            const key = event.code.replace('Key', '').replace('Left', '_LEFT');
            if (keys.hasOwnProperty(key)) keys[key] = false;
        }

        function startPaperAnimation(showTexture) {
            if (!paperAnimationActive) {
                paperAnimationActive = true;
                paperAnimationTime = 0;
                paperTargetOpacity = showTexture ? 1.0 : 0.0;
                paperCurrentOpacity = showTexture ? 0.0 : 1.0;
                
                // Set the paper to use the print material immediately
                if (showTexture && paperMesh && paperPrintMaterial) {
                    paperMesh.material = paperPrintMaterial;
                    paperPrintMaterial.opacity = paperCurrentOpacity;
                }
                
                console.log(`Paper animation started: ${showTexture ? 'SHOWING' : 'HIDING'} texture`);
            }
        }

        function updatePaperAnimation(deltaTime) {
            if (paperAnimationActive) {
                paperAnimationTime += deltaTime;
                const progress = Math.min(paperAnimationTime / PAPER_ANIMATION_DURATION, 1.0);
                
                // Smooth easing function (ease-in-out)
                const easeProgress = progress < 0.5 
                    ? 2 * progress * progress 
                    : -1 + (4 - 2 * progress) * progress;
                
                // Interpolate opacity
                paperCurrentOpacity = paperCurrentOpacity + (paperTargetOpacity - paperCurrentOpacity) * easeProgress;
                
                if (paperMesh && paperPrintMaterial && paperMesh.material === paperPrintMaterial) {
                    paperPrintMaterial.opacity = paperCurrentOpacity;
                }
                
                // Animation finished
                if (progress >= 1.0) {
                    paperAnimationActive = false;
                    
                    // If we're hiding the texture and animation is complete, switch back to original material
                    if (paperTargetOpacity === 0 && paperMesh && originalPaperMaterial) {
                        paperMesh.material = originalPaperMaterial;
                        console.log("Paper animation complete: texture HIDDEN, switched back to original material");
                    } else if (paperTargetOpacity === 1.0) {
                        console.log("Paper animation complete: texture FULLY VISIBLE");
                    }
                }
            }
        }

        function handleInteraction() {
            interactionRaycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const interactableSceneObjects = [];
            interactiveObjectNames.forEach(name => {
                const obj = model.getObjectByName(name);
                if (obj) interactableSceneObjects.push(obj);
            });
            const intersects = interactionRaycaster.intersectObjects(interactableSceneObjects, true);

            if (intersects.length > 0 && intersects[0].distance < INTERACTION_DISTANCE) {
                const intersectedRawObject = intersects[0].object;
                let interactiveObjectName = intersectedRawObject.name;
                let current = intersectedRawObject;
                
                while (current && !interactiveObjectNames.includes(current.name)) {
                    current = current.parent;
                }
                if (current) {
                    interactiveObjectName = current.name;
                } else {
                    return; // Not an object we care about for top-level interaction
                }

                if (interactiveObjectName === 'Object_13108' && tvScreenMesh && originalTVMaterial && staticTVMaterial) {
                    isTVOn = !isTVOn;
                    tvScreenMesh.material = isTVOn ? staticTVMaterial : originalTVMaterial;
                    console.log("TV toggled:", isTVOn ? "ON" : "OFF");
                } else if (interactiveObjectName === 'Object_23' || interactiveObjectName === 'Object_23025') { // Interacting with the paper's designated interactive parent/group OR Object_23025
                    if (paperMesh && originalPaperMaterial && paperPrintMaterial && !paperAnimationActive) {
                        // Toggle paper texture visibility with animation
                        isPaperTextureVisible = !isPaperTextureVisible;
                        startPaperAnimation(isPaperTextureVisible);
                        
                        if (interactiveObjectName === 'Object_23025') {
                            console.log("Object_23025 interacted - animating Object_23045 with kertasprint.jpeg");
                        }
                    } else if (paperAnimationActive) {
                        console.log("Paper animation in progress, please wait...");
                    } else {
                        console.error("Paper Toggle: ERROR - paperMesh or materials not ready for interaction.");
                    }
                } else if (interactiveObjectName === 'Object_18' && steamObject) {
                    isSteamActive = !isSteamActive;
                    if (isSteamActive) {
                        steamAnimationTime = 0;
                        steamObject.position.copy(originalSteamPosition);
                        if (steamObject.material) steamObject.material.opacity = originalSteamOpacity;
                        steamObject.visible = true;
                        console.log("Steam activated");
                    } else {
                        steamObject.visible = false;
                        console.log("Steam deactivated");
                    }
                }
            }
        }

        function updatePlayerAndCamera(deltaTime) {
            // --- Player Movement Logic ---
            if (controls.isLocked) {
                const camRef = controls.getObject();
                const speed = (keys.SHIFT_LEFT ? 1.5 : 1) * 8.0 * deltaTime;
                camRef.getWorldDirection(_forward);
                _forward.y = 0; _forward.normalize();
                _right.crossVectors(camRef.up, _forward).normalize();
                _movementDirection.set(0, 0, 0);
                if (keys.W) _movementDirection.add(_forward);
                if (keys.S) _movementDirection.sub(_forward);
                if (keys.A) _movementDirection.add(_right);
                if (keys.D) _movementDirection.sub(_right);

                if (!player.isGrounded) player.velocity.y -= GRAVITY * deltaTime;
                if (keys.SPACE && player.isGrounded && player.canJump) {
                    player.velocity.y = JUMP_IMPULSE;
                    player.isGrounded = false;
                    player.canJump = false;
                }
                if (!keys.SPACE) player.canJump = true;

                let dX = 0, dZ = 0;
                if (_movementDirection.lengthSq() > 0) {
                    _movementDirection.normalize();
                    dX = _movementDirection.x * speed;
                    dZ = _movementDirection.z * speed;
                }

                const groundRayOrigin = new THREE.Vector3(player.position.x, player.position.y + PLAYER_FEET_RADIUS * 0.5, player.position.z);
                raycaster.set(groundRayOrigin, new THREE.Vector3(0, -1, 0));
                raycaster.far = Math.abs(player.velocity.y * deltaTime) + PLAYER_FEET_RADIUS * 1.1;
                const groundHits = raycaster.intersectObjects(collidableMeshes, true);
                player.isGrounded = false;
                if (player.velocity.y <= 0 && groundHits.length > 0 && groundHits[0].distance <= PLAYER_FEET_RADIUS * 1.01) {
                    player.position.y = groundHits[0].point.y;
                    player.velocity.y = 0;
                    player.isGrounded = true;
                }
                if (!player.isGrounded) player.position.y += player.velocity.y * deltaTime;

                if (player.velocity.y > 0) { 
                    const headOrigin = player.position.clone().add(new THREE.Vector3(0, PLAYER_COLLISION_HEIGHT - 0.1, 0));
                    raycaster.set(headOrigin, new THREE.Vector3(0, 1, 0));
                    raycaster.far = player.velocity.y * deltaTime + 0.2;
                    const headHits = raycaster.intersectObjects(collidableMeshes, true);
                    if (headHits.length > 0) {
                        player.position.y = headHits[0].point.y - PLAYER_COLLISION_HEIGHT;
                        player.velocity.y = 0;
                    }
                }

                const tempPos = player.position.clone();
                tempPos.x += dX; tempPos.z += dZ;
                player.boundingBox.setFromCenterAndSize(
                    new THREE.Vector3(tempPos.x, player.position.y + PLAYER_COLLISION_HEIGHT / 2, tempPos.z),
                    new THREE.Vector3(playerRadiusBuffer * 2, PLAYER_COLLISION_HEIGHT, playerRadiusBuffer * 2)
                );
                let canMoveH = true; let stepped = false;
                if (dX !== 0 || dZ !== 0) {
                    for (const mesh of collidableMeshes) {
                        const box = collisionBoundingBoxes.get(mesh.name);
                        if (box && !box.isEmpty() && player.boundingBox.intersectsBox(box)) {
                            let didStep = false;
                            const headClearOrigin = player.position.clone();
                            headClearOrigin.x += _movementDirection.x * playerRadiusBuffer * 0.5;
                            headClearOrigin.z += _movementDirection.z * playerRadiusBuffer * 0.5;
                            headClearOrigin.y += MAX_STEP_HEIGHT + 0.1; 
                            raycaster.set(headClearOrigin, _movementDirection);
                            raycaster.far = playerRadiusBuffer;
                            if (raycaster.intersectObject(mesh, true).length === 0) { 
                                const stepSurfOrigin = new THREE.Vector3(tempPos.x, player.position.y + MAX_STEP_HEIGHT + PLAYER_FEET_RADIUS, tempPos.z);
                                raycaster.set(stepSurfOrigin, new THREE.Vector3(0, -1, 0)); 
                                raycaster.far = MAX_STEP_HEIGHT + PLAYER_FEET_RADIUS * 1.5;
                                const stepHits = raycaster.intersectObject(mesh, true);
                                if (stepHits.length > 0) {
                                    const yDiff = stepHits[0].point.y - player.position.y;
                                    if (yDiff >= -0.01 && yDiff <= MAX_STEP_HEIGHT) {
                                        player.position.set(tempPos.x, stepHits[0].point.y, tempPos.z);
                                        player.isGrounded = true; player.velocity.y = 0;
                                        stepped = true; didStep = true; break;
                                    }
                                }
                            }
                            if (!didStep) { canMoveH = false; break; }
                        }
                    }
                }
                if (!stepped && canMoveH) player.position.set(tempPos.x, player.position.y, tempPos.z);
                camRef.position.set(player.position.x, player.position.y + PLAYER_EYE_HEIGHT, player.position.z);
            } else { // Controls not locked
                 player.velocity.x = 0;
                 player.velocity.z = 0;
            }
            // --- End Player Movement Logic ---

            // TV Static Animation
            if (isTVOn && staticTexture && tvScreenMesh && staticTVMaterial === tvScreenMesh.material) {
                staticTexture.offset.x += Math.random() * 0.1 - 0.05;
                staticTexture.offset.y += Math.random() * 0.1 - 0.05;
                staticTexture.offset.x = (staticTexture.offset.x % 1 + 1) % 1;
                staticTexture.offset.y = (staticTexture.offset.y % 1 + 1) % 1;
            }

            // Steam Animation
            if (isSteamActive && steamObject && originalSteamPosition && steamObject.material) {
                steamAnimationTime += deltaTime;
                let loopProgress = (steamAnimationTime % STEAM_LOOP_DURATION) / STEAM_LOOP_DURATION;
                steamObject.position.set(
                    originalSteamPosition.x,
                    originalSteamPosition.y + loopProgress * STEAM_MAX_HEIGHT_OFFSET,
                    originalSteamPosition.z
                );
                steamObject.material.opacity = originalSteamOpacity * (1 - loopProgress);
            }

            // Paper Animation Update
            updatePaperAnimation(deltaTime);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(0.05, clock.getDelta());
            updatePlayerAndCamera(deltaTime);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>