<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDGEHOG ISLAND LABOLATORY - FPS with Jump & Gravity</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #controls-help {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            font-family: sans-serif;
            border-radius: 8px;
            z-index: 100;
            font-size: 14px;
            line-height: 1.6;
            max-width: 250px;
        }

        #controls-help h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 16px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        #controls-help p {
            margin: 4px 0;
        }

        #controls-help kbd {
            background-color: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 13px;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 200;
        }

        #instructions {
            width: 50%;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="blocker">
        <div id="instructions">
            <p style="font-size:36px">Click to play</p>
            <p>
                W, A, S, D: Move<br />
                Shift: Sprint<br />
                Space: Jump<br />
                Mouse: Look around
            </p>
        </div>
    </div>

    <div id="controls-help">
        <h3>Petunjuk Kontrol</h3>
        <p><kbd>W</kbd> - Maju</p>
        <p><kbd>A</kbd> - Kiri (Strafe)</p>
        <p><kbd>S</kbd> - Mundur</p>
        <p><kbd>D</kbd> - Kanan (Strafe)</p>
        <p><kbd>Shift Kiri</kbd> - Sprint</p>
        <p><kbd>Space</kbd> - Lompat</p>
        <p><strong>Mouse</strong> - Lihat Sekeliling (Klik layar untuk mengaktifkan)</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let scene, camera, renderer, model, controls;
        const clock = new THREE.Clock();

        const keys = {
            W: false, A: false, S: false, D: false,
            SHIFT_LEFT: false,
            SPACE: false // Ditambahkan untuk lompat
        };

        // Konstanta Fisika dan Player
        const PLAYER_EYE_HEIGHT = 10.5;     // Jarak dari kaki pemain ke kamera. Sesuaikan dengan skala.
        const PLAYER_COLLISION_HEIGHT = 1.8; // Tinggi total pemain untuk tabrakan kepala.
        const GRAVITY = 7.0;               // Percepatan gravitasi (unit/s^2). Sesuaikan.
        const JUMP_IMPULSE = 3.5;          // Kecepatan awal ke atas untuk lompat (unit/s). Sesuaikan.
        const MAX_STEP_HEIGHT = 0.6;        // Tinggi maksimal pemain bisa naik otomatis. Sesuaikan.
        const playerRadiusBuffer = 3.5;     // Radius horizontal pemain untuk tabrakan
        const PLAYER_FEET_RADIUS = playerRadiusBuffer * 0.8; // Untuk offset pengecekan tanah

        let player = {
            position: new THREE.Vector3(),    // Posisi kaki pemain
            velocity: new THREE.Vector3(),    // Kecepatan saat ini (terutama sumbu Y)
            isGrounded: false,
            canJump: true,
            boundingBox: new THREE.Box3()     // Bounding box pemain
        };

        const raycaster = new THREE.Raycaster();
        const collidableMeshes = [];
        const collidableObjectNames = [
            'Object_13', 'Object_22', 'Object_23', 'Object_14',
            'Object_15', 'Object_16', 'Object_18',
            'Object_6' // PASTIKAN INI NAMA OBJEK PLATFORM/LANTAI UTAMA ANDA
        ];
        const collisionBoundingBoxes = new Map();

        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');

        // Helper vectors, dideklarasikan global agar tidak dibuat ulang setiap frame
        const _worldDirection = new THREE.Vector3();
        const _movementDirection = new THREE.Vector3();
        const _forward = new THREE.Vector3();
        const _right = new THREE.Vector3();


        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            controls = new PointerLockControls(camera, document.body);
            // Tidak menambahkan controls.getObject() ke scene secara langsung,
            // karena kamera akan mengikuti posisi player.position + PLAYER_EYE_HEIGHT

            instructions.addEventListener('click', function () {
                controls.lock();
            });

            controls.addEventListener('lock', function () {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
                document.getElementById('controls-help').style.display = 'block';
            });

            controls.addEventListener('unlock', function () {
                blocker.style.display = 'flex';
                instructions.style.display = '';
                document.getElementById('controls-help').style.display = 'none';
            });
            document.getElementById('controls-help').style.display = 'none';


            setupLighting();

            const loader = new GLTFLoader();
            loader.load(
                'EDGEHOG ISLAND LABOLATORY.glb',
                function (gltf) {
                    model = gltf.scene;
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            if (collidableObjectNames.includes(child.name)) {
                                collidableMeshes.push(child);
                                const boundingBox = new THREE.Box3().setFromObject(child);
                                collisionBoundingBoxes.set(child.name, boundingBox);
                            }
                        }
                    });
                    model.scale.set(0.05, 0.05, 0.05); // Sesuaikan skala model jika perlu
                    scene.add(model);
                    console.log("Model loaded successfully.");
                    if (collidableMeshes.length > 0) {
                        console.log(`Found ${collidableMeshes.length} collidable meshes:`, collidableMeshes.map(m => m.name));
                    } else {
                        console.warn("No collidable meshes found with the specified names. Ground detection and collision might not work.");
                    }

                    const targetObjectName = 'Object_6'; // Objek untuk posisi awal
                    let targetObject = model.getObjectByName(targetObjectName);

                    if (targetObject) {
                        console.log(`Found ${targetObjectName} for initial positioning.`);
                        const boundingBox = new THREE.Box3().setFromObject(targetObject);
                        const objectWorldPosition = new THREE.Vector3();
                        targetObject.getWorldPosition(objectWorldPosition);

                        player.position.set(
                            objectWorldPosition.x,
                            boundingBox.max.y, // Kaki pemain di atas permukaan objek
                            objectWorldPosition.z
                        );
                        player.isGrounded = true;
                    } else {
                        console.warn(`${targetObjectName} not found. Using default player position.`);
                        player.position.set(0, 10, 5); // Posisi awal default (Y=10 agar tidak tembus lantai jika lantai di Y=0)
                        player.isGrounded = false; // Mungkin jatuh jika tidak ada apa-apa di bawah
                    }
                    // Atur posisi kamera berdasarkan kaki pemain + tinggi mata
                    controls.getObject().position.set(
                        player.position.x,
                        player.position.y + PLAYER_EYE_HEIGHT,
                        player.position.z
                    );

                    console.log(`Initial player feet position:`, player.position);
                    console.log(`Initial camera position:`, controls.getObject().position);
                    animate();
                },
                (xhr) => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
                (error) => console.error('Error loading GLB model:', error)
            );

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize, false);
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 3.5);
            mainDirectionalLight.position.set(40, 50, 30);
            mainDirectionalLight.castShadow = true;
            mainDirectionalLight.shadow.mapSize.width = 2048;
            mainDirectionalLight.shadow.mapSize.height = 2048;
            mainDirectionalLight.shadow.camera.near = 0.5;
            mainDirectionalLight.shadow.camera.far = 150;
            mainDirectionalLight.shadow.camera.left = -60;
            mainDirectionalLight.shadow.camera.right = 60;
            mainDirectionalLight.shadow.camera.top = 60;
            mainDirectionalLight.shadow.camera.bottom = -60;
            mainDirectionalLight.shadow.bias = -0.0005;
            scene.add(mainDirectionalLight);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': keys.W = true; break;
                case 'KeyA': keys.A = true; break;
                case 'KeyS': keys.S = true; break;
                case 'KeyD': keys.D = true; break;
                case 'ShiftLeft': keys.SHIFT_LEFT = true; break;
                case 'Space': keys.SPACE = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': keys.W = false; break;
                case 'KeyA': keys.A = false; break;
                case 'KeyS': keys.S = false; break;
                case 'KeyD': keys.D = false; break;
                case 'ShiftLeft': keys.SHIFT_LEFT = false; break;
                case 'Space': keys.SPACE = false; break;
            }
        }

        // ... (kode di atas fungsi updatePlayerAndCamera tetap sama) ...

        function updatePlayerAndCamera(deltaTime) {
            if (!controls.isLocked) {
                player.velocity.x = 0;
                player.velocity.z = 0;
                return;
            }

            const cameraReference = controls.getObject();
            const effectiveMoveSpeed = 8.0;
            const sprintMultiplier = 1.5;

            const actualSpeed = (keys.SHIFT_LEFT ? sprintMultiplier : 1) * effectiveMoveSpeed * deltaTime;

            // --- Handle Horizontal Movement Input ---
            cameraReference.getWorldDirection(_forward);
            _forward.y = 0;
            _forward.normalize();
            _right.crossVectors(cameraReference.up, _forward).normalize();

            _movementDirection.set(0, 0, 0);
            if (keys.W) _movementDirection.add(_forward);
            if (keys.S) _movementDirection.sub(_forward);
            if (keys.A) _movementDirection.add(_right); // KOREKSI: Strafe Kiri Standar
            if (keys.D) _movementDirection.sub(_right); // KOREKSI: Strafe Kanan Standar


            // --- Apply Gravity ---
            if (!player.isGrounded) {
                player.velocity.y -= GRAVITY * deltaTime;
            }

            // --- Handle Jumping ---
            if (keys.SPACE && player.isGrounded && player.canJump) {
                player.velocity.y = JUMP_IMPULSE;
                player.isGrounded = false;
                player.canJump = false;
            }
            if (!keys.SPACE) {
                player.canJump = true;
            }

            // --- Calculate Intended Horizontal Position Change ---
            let intendedDeltaX = 0;
            let intendedDeltaZ = 0;
            if (_movementDirection.lengthSq() > 0) {
                _movementDirection.normalize();
                intendedDeltaX = _movementDirection.x * actualSpeed;
                intendedDeltaZ = _movementDirection.z * actualSpeed;
            }

            // --- Vertical Collision and Ground Detection ---
            const playerBaseY = player.position.y;
            const groundRayOrigin = new THREE.Vector3(player.position.x, playerBaseY + PLAYER_FEET_RADIUS * 0.5, player.position.z);
            const groundRayLength = Math.abs(player.velocity.y * deltaTime) + PLAYER_FEET_RADIUS * 1.1;

            raycaster.set(groundRayOrigin, new THREE.Vector3(0, -1, 0));
            raycaster.far = groundRayLength;
            const groundIntersects = raycaster.intersectObjects(collidableMeshes, true);

            player.isGrounded = false;

            if (player.velocity.y <= 0) {
                if (groundIntersects.length > 0) {
                    const closestGround = groundIntersects[0];
                    if (closestGround.distance <= PLAYER_FEET_RADIUS * 1.0 + 0.01) { // Tambah epsilon kecil
                        player.position.y = closestGround.point.y;
                        player.velocity.y = 0;
                        player.isGrounded = true;
                    }
                }
            }

            if (!player.isGrounded) {
                player.position.y += player.velocity.y * deltaTime;
            }

            // --- Head Collision ---
            if (player.velocity.y > 0) {
                const headCheckOrigin = player.position.clone().add(new THREE.Vector3(0, PLAYER_COLLISION_HEIGHT - 0.1, 0));
                raycaster.set(headCheckOrigin, new THREE.Vector3(0, 1, 0));
                raycaster.far = player.velocity.y * deltaTime + 0.2;
                const headIntersects = raycaster.intersectObjects(collidableMeshes, true);
                if (headIntersects.length > 0) {
                    player.position.y = headIntersects[0].point.y - PLAYER_COLLISION_HEIGHT;
                    player.velocity.y = 0;
                }
            }

            // --- Horizontal Collision & Step-Up (REVISED LOGIC) ---
            const tempFuturePlayerPos = player.position.clone();
            tempFuturePlayerPos.x += intendedDeltaX;
            tempFuturePlayerPos.z += intendedDeltaZ;

            player.boundingBox.setFromCenterAndSize(
                new THREE.Vector3(tempFuturePlayerPos.x, player.position.y + PLAYER_COLLISION_HEIGHT / 2, tempFuturePlayerPos.z),
                new THREE.Vector3(playerRadiusBuffer * 2, PLAYER_COLLISION_HEIGHT, playerRadiusBuffer * 2)
            );

            let canMoveHorizontally = true;         // Asumsikan bisa bergerak
            let collisionResolvedByStepping = false; // Flag jika tabrakan diatasi dengan step-up

            if (intendedDeltaX !== 0 || intendedDeltaZ !== 0) { // Hanya cek jika ada niat bergerak horizontal
                for (let mesh of collidableMeshes) {
                    const meshBoundingBox = collisionBoundingBoxes.get(mesh.name);
                    if (meshBoundingBox && player.boundingBox.intersectsBox(meshBoundingBox)) {
                        // Terdeteksi tabrakan. Coba step-up ke mesh ini.
                        let didStepThisMesh = false;

                        const headClearanceCheckOrigin = player.position.clone();
                        // Proyeksikan titik cek sedikit ke arah gerakan untuk head clearance
                        const checkOffsetScale = playerRadiusBuffer * 0.5; // Seberapa jauh ke depan untuk cek head clearance
                        headClearanceCheckOrigin.x += _movementDirection.x * checkOffsetScale;
                        headClearanceCheckOrigin.z += _movementDirection.z * checkOffsetScale;
                        headClearanceCheckOrigin.y += MAX_STEP_HEIGHT + 0.1; // Dari sedikit di atas tinggi step maksimal

                        raycaster.set(headClearanceCheckOrigin, _movementDirection); // Raycast ke arah gerakan
                        raycaster.far = playerRadiusBuffer; // Jarak cek yang relevan
                        const headClearanceIntersects = raycaster.intersectObject(mesh, true);

                        if (headClearanceIntersects.length === 0) { // Jika ada ruang di atas untuk kepala
                            const stepSurfaceRayOrigin = new THREE.Vector3(
                                tempFuturePlayerPos.x, // Cek dari posisi XZ yang dituju
                                player.position.y + MAX_STEP_HEIGHT + PLAYER_FEET_RADIUS, // Mulai raycast dari atas tinggi step
                                tempFuturePlayerPos.z
                            );
                            raycaster.set(stepSurfaceRayOrigin, new THREE.Vector3(0, -1, 0)); // Raycast ke bawah
                            raycaster.far = MAX_STEP_HEIGHT + PLAYER_FEET_RADIUS * 1.5; // Jarak cek ke bawah
                            const stepSurfaceIntersects = raycaster.intersectObject(mesh, true);

                            if (stepSurfaceIntersects.length > 0) {
                                const stepSurfaceY = stepSurfaceIntersects[0].point.y;
                                // Cek apakah permukaan pijakan valid (di atas atau sama dengan posisi kaki saat ini, dan dalam jangkauan MAX_STEP_HEIGHT)
                                const yDifference = stepSurfaceY - player.position.y;
                                if (yDifference >= -0.01 && yDifference <= MAX_STEP_HEIGHT) { // Izinkan toleransi kecil untuk permukaan datar
                                    player.position.x = tempFuturePlayerPos.x; // Pindah ke XZ yang dituju
                                    player.position.z = tempFuturePlayerPos.z;
                                    player.position.y = stepSurfaceY;      // Naikkan ke permukaan pijakan
                                    player.isGrounded = true;
                                    player.velocity.y = 0;
                                    collisionResolvedByStepping = true; // Tabrakan diatasi dengan step-up
                                    didStepThisMesh = true;
                                    // console.log("Stepped up onto:", mesh.name, "to Y:", stepSurfaceY.toFixed(2));
                                    break; // Keluar dari loop collidableMeshes karena tabrakan sudah diatasi
                                }
                            }
                        }

                        if (!didStepThisMesh) {
                            // Tabrakan terjadi, dan tidak bisa step-up ke mesh INI.
                            // Ini berarti ini adalah dinding atau halangan yang terlalu tinggi.
                            canMoveHorizontally = false;
                            // console.log("Wall collision with:", mesh.name, ". Preventing horizontal move.");
                            break; // Keluar dari loop collidableMeshes, gerakan diblokir.
                        }
                    }
                }
            }


            // --- Final Application of Movement ---
            if (collisionResolvedByStepping) {
                // Posisi sudah diperbarui selama step-up yang berhasil.
            } else if (canMoveHorizontally) {
                // Tidak ada tabrakan yang menghalangi, atau tidak ada tabrakan sama sekali.
                player.position.x = tempFuturePlayerPos.x;
                player.position.z = tempFuturePlayerPos.z;
            } else {
                // Gerakan diblokir oleh tabrakan yang tidak bisa di-step-up.
                // console.log("Final decision: No horizontal movement this frame due to wall.");
            }

            // --- Final Camera Update ---
            cameraReference.position.x = player.position.x;
            cameraReference.position.y = player.position.y + PLAYER_EYE_HEIGHT;
            cameraReference.position.z = player.position.z;
        }

        // ... (sisa kode seperti onWindowResize, animate, init tetap sama) ...


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(0.05, clock.getDelta()); // Batasi deltaTime untuk mencegah bug fisika saat frame drop
            updatePlayerAndCamera(deltaTime);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>