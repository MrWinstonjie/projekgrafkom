<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDGEHOG ISLAND LABOLATORY Viewer - FPS with Collision & Interaction</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #controls-help {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            font-family: sans-serif;
            border-radius: 8px;
            z-index: 100;
            font-size: 14px;
            line-height: 1.6;
            max-width: 250px;
        }
        #controls-help h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 16px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }
        #controls-help p {
            margin: 4px 0;
        }
        #controls-help kbd {
            background-color: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div id="controls-help">
        <h3>Petunjuk Kontrol</h3>
        <p><kbd>W</kbd> - Maju</p>
        <p><kbd>A</kbd> - Kiri (Strafe)</p>
        <p><kbd>S</kbd> - Mundur</p>
        <p><kbd>D</kbd> - Kanan (Strafe)</p>
        <p><kbd>Shift Kiri</kbd> - Sprint</p>
        <p><kbd>E</kbd> - Interaksi</p>
        <p><strong>Mouse</strong> - Lihat Sekeliling</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, model, controls;
        const clock = new THREE.Clock();

        const keys = {
            W: false, A: false, S: false, D: false,
            SHIFT_LEFT: false, E: false
        };

        let currentMoveSpeed = 2.15;
        const sprintMultiplier = 5.5;
        const eyeHeightFromSurface = 300.8;
        const initialLookAheadDistance = 0.1;

        let targetSurfaceY = 0;
        let onTargetObject = false;

        const movementRaycaster = new THREE.Raycaster(); // Renamed for clarity
        const collidableMeshes = [];
        const playerRadiusBuffer = 3.5;
        const collidableObjectNames = [
            'Object_13', 'Object_22', 'Object_23', 'Object_14',
            'Object_15', 'Object_16' // 'Object_18' might be interactable OR collidable, ensure it's not overly restricted
        ];
        const collisionBoundingBoxes = new Map();

        // Interaction
        const interactableObjectNames = ['Object_17', 'Object_18', 'Object_25'];
        const interactables = []; // Will store the actual THREE.Object3D instances
        const interactionRaycaster = new THREE.Raycaster();
        const interactionDistance = 150; // Max distance player can interact from
        const animationDuration = 0.5; // Duration of the bob animation in seconds
        const animationAmplitude = 8; // How high the object bobs

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.enablePan = false;
            controls.enableZoom = false;
            controls.minDistance = 0.01;
            controls.maxDistance = 1;
            controls.minPolarAngle = 0.05;
            controls.maxPolarAngle = Math.PI - 0.05;

            setupLighting();

            const loader = new GLTFLoader();
            loader.load(
                'EDGEHOG ISLAND LABOLATORY.glb',
                function (gltf) {
                    model = gltf.scene;
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;

                            if (collidableObjectNames.includes(child.name)) {
                                collidableMeshes.push(child);
                                const boundingBox = new THREE.Box3().setFromObject(child);
                                collisionBoundingBoxes.set(child.name, boundingBox);
                                // console.log(`Collision bounding box for ${child.name}:`, boundingBox);
                            }

                            if (interactableObjectNames.includes(child.name)) {
                                child.userData.isInteractable = true;
                                child.userData.isAnimating = false;
                                child.userData.animationStartTime = 0;
                                child.userData.originalPosition = child.position.clone(); // Store original LOCAL position
                                interactables.push(child);
                                console.log(`Found interactable object: ${child.name}`);

                                // If an object is both interactable and collidable, ensure it's in collidableMeshes too.
                                // For lab tubes, they probably should be collidable too.
                                if (!collidableMeshes.includes(child)) {
                                    collidableMeshes.push(child);
                                    const boundingBox = new THREE.Box3().setFromObject(child);
                                    collisionBoundingBoxes.set(child.name, boundingBox);
                                    console.log(`Interactable ${child.name} also added as collidable.`);
                                }
                            }
                        }
                    });
                    scene.add(model);
                    console.log("Model loaded successfully.");
                    if (collidableMeshes.length > 0) {
                        console.log(`Found ${collidableMeshes.length} collidable meshes:`, collidableMeshes.map(m => m.name));
                    } else {
                        console.warn("No collidable meshes found with the specified names. Collision detection might not work as expected.");
                    }
                    if (interactables.length > 0) {
                        console.log(`Found ${interactables.length} interactable objects:`, interactables.map(m => m.name));
                    } else {
                        console.warn("No interactable objects found with the specified names.");
                    }


                    const targetObjectName = 'Object_6';
                    let targetObject = null;
                    model.traverse((child) => {
                        if (child.name === targetObjectName) {
                            targetObject = child;
                        }
                    });

                    if (targetObject) {
                        onTargetObject = true;
                        const boundingBox = new THREE.Box3().setFromObject(targetObject);
                        targetSurfaceY = boundingBox.max.y;
                        const objectWorldPosition = new THREE.Vector3();
                        targetObject.getWorldPosition(objectWorldPosition);
                        camera.position.set(
                            objectWorldPosition.x,
                            targetSurfaceY + eyeHeightFromSurface,
                            objectWorldPosition.z
                        );
                    } else {
                        onTargetObject = false;
                        camera.position.set(0, eyeHeightFromSurface, 5);
                    }

                    const lookDirection = new THREE.Vector3();
                    camera.getWorldDirection(lookDirection);
                    controls.target.copy(camera.position).addScaledVector(lookDirection, initialLookAheadDistance);
                    controls.update();
                    animate();
                },
                (xhr) => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
                (error) => console.error('An error happened while loading the GLB model:', error)
            );

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize, false);
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 4.8);
            mainDirectionalLight.position.set(30, 40, 25);
            mainDirectionalLight.castShadow = true;
            mainDirectionalLight.shadow.mapSize.width = 2048;
            mainDirectionalLight.shadow.mapSize.height = 2048;
            mainDirectionalLight.shadow.camera.near = 0.5;
            mainDirectionalLight.shadow.camera.far = 100;
            mainDirectionalLight.shadow.camera.left = -30;
            mainDirectionalLight.shadow.camera.right = 30;
            mainDirectionalLight.shadow.camera.top = 30;
            mainDirectionalLight.shadow.camera.bottom = -30;
            mainDirectionalLight.shadow.bias = -0.0005;
            scene.add(mainDirectionalLight);
            const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x303030, 0.8);
            scene.add(hemisphereLight);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': keys.W = true; break;
                case 'KeyA': keys.A = true; break;
                case 'KeyS': keys.S = true; break;
                case 'KeyD': keys.D = true; break;
                case 'ShiftLeft': keys.SHIFT_LEFT = true; break;
                case 'KeyE':
                    if (!keys.E) { // Process only on first press to avoid multiple triggers if key held
                        handleInteraction();
                    }
                    keys.E = true;
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': keys.W = false; break;
                case 'KeyA': keys.A = false; break;
                case 'KeyS': keys.S = false; break;
                case 'KeyD': keys.D = false; break;
                case 'ShiftLeft': keys.SHIFT_LEFT = false; break;
                case 'KeyE': keys.E = false; break;
            }
        }

        function handleInteraction() {
            if (!model || interactables.length === 0) return;

            // Raycast from camera center
            interactionRaycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const intersects = interactionRaycaster.intersectObjects(interactables, false); // false: don't check children of interactables themselves

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object; // This is the Mesh
                // We stored userData on the mesh itself if it's in interactableObjectNames
                if (intersects[0].distance < interactionDistance) {
                    if (intersectedObject.userData.isInteractable && !intersectedObject.userData.isAnimating) {
                        intersectedObject.userData.isAnimating = true;
                        intersectedObject.userData.animationStartTime = clock.getElapsedTime();
                        console.log(`Interacting with ${intersectedObject.name}`);
                        // The originalPosition is already stored in userData
                    }
                }
            }
        }


        function checkCollision(currentPosition, moveDirection, distance) {
            const checkPoints = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(playerRadiusBuffer, 0, 0),
                new THREE.Vector3(-playerRadiusBuffer, 0, 0),
                new THREE.Vector3(0, 0, playerRadiusBuffer),
                new THREE.Vector3(0, 0, -playerRadiusBuffer),
            ];

            for (let checkPoint of checkPoints) {
                const rayStart = currentPosition.clone().add(checkPoint);
                movementRaycaster.set(rayStart, moveDirection);
                const intersects = movementRaycaster.intersectObjects(collidableMeshes, true);
                if (intersects.length > 0 && intersects[0].distance < distance + playerRadiusBuffer) {
                    return true;
                }
            }

            const futurePosition = currentPosition.clone().add(moveDirection.clone().multiplyScalar(distance));
            const playerBoundingBox = new THREE.Box3().setFromCenterAndSize(
                futurePosition,
                new THREE.Vector3(playerRadiusBuffer * 2, eyeHeightFromSurface * 0.8, playerRadiusBuffer * 2) // Reduced height for player BB
            );

            for (let mesh of collidableMeshes) {
                const meshBoundingBox = collisionBoundingBoxes.get(mesh.name);
                if (meshBoundingBox && playerBoundingBox.intersectsBox(meshBoundingBox)) {
                    return true;
                }
            }
            return false;
        }

        function updateCameraPosition(deltaTime) {
            const speed = (keys.SHIFT_LEFT ? sprintMultiplier : 1) * currentMoveSpeed;
            const actualSpeedPerFrame = speed * deltaTime * 60;

            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();

            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            right.crossVectors(forward, camera.up).normalize();

            const combinedMoveDirection = new THREE.Vector3();
            if (keys.W) combinedMoveDirection.add(forward);
            if (keys.S) combinedMoveDirection.sub(forward);
            if (keys.A) combinedMoveDirection.sub(right);
            if (keys.D) combinedMoveDirection.add(right);

            if (combinedMoveDirection.lengthSq() > 0) {
                combinedMoveDirection.normalize();
                const intendedDistance = actualSpeedPerFrame;
                if (!checkCollision(camera.position, combinedMoveDirection, intendedDistance)) {
                    camera.position.add(combinedMoveDirection.multiplyScalar(intendedDistance));
                } else {
                    const reducedDistance = intendedDistance * 0.1;
                    if (!checkCollision(camera.position, combinedMoveDirection, reducedDistance)) {
                        camera.position.add(combinedMoveDirection.multiplyScalar(reducedDistance));
                    }
                }
            }

            if (onTargetObject) {
                camera.position.y = targetSurfaceY + eyeHeightFromSurface;
            }

            const lookDirection = new THREE.Vector3();
            camera.getWorldDirection(lookDirection);
            controls.target.copy(camera.position).addScaledVector(lookDirection, initialLookAheadDistance);
        }

        function updateAnimations(currentTime) {
            for (const obj of interactables) {
                if (obj.userData.isAnimating) {
                    const elapsedTime = currentTime - obj.userData.animationStartTime;
                    if (elapsedTime < animationDuration) {
                        const animationProgress = elapsedTime / animationDuration; // 0 to 1
                        // Simple bobbing: up and then back down using a sine wave
                        // Math.PI makes it go up (0 to 1) and back down (1 to 0) for sin argument 0 to PI
                        const bobOffset = Math.sin(animationProgress * Math.PI) * animationAmplitude;
                        obj.position.y = obj.userData.originalPosition.y + bobOffset;
                    } else {
                        obj.userData.isAnimating = false;
                        obj.position.copy(obj.userData.originalPosition); // Reset to original local position
                    }
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const currentTime = clock.getElapsedTime(); // Get current time for animations

            updateCameraPosition(deltaTime);
            updateAnimations(currentTime); // Update interactable object animations

            controls.update();
            renderer.render(scene, camera);QA
        }

        init();
    </script>
</body>
</html>